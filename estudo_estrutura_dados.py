# -*- coding: utf-8 -*-
"""atividades_estruturadedados1010.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wXugxk7JSNoE1JBBHtyJ72zjTqR0pByr
"""

# 1) Escreva uma função, que dados dois números inteiros positivos, calcule e retorne o Máximo Divisor Comum (MDC) entre os dois.

num1 = int(input("Informe o primeiro valor: "))
num2 = int(input("Informe o segundo valor: "))

def mdc(a, b):
  while b != 0:
    resto = a % b
    a = b
    b = resto

  return a

print(f"\nO Máximo Divisor Comum de {num1} e {num2} é {mdc(num1, num2)}")

# 2) Escreva uma função, que dados dois números inteiros positivos, calcule e retorne o Mínimo Múltiplo Comum (MMC) entre os dois.

def calc_mdc(a, b):
    while b:
        a, b = b, a % b
    return a

def cal_mmc(a, b):
    return abs(a * b) // calc_mdc(a, b)

num1 = int(input("Informe o primeiro valor: "))
num2 = int(input("Informe o segundo valor: "))

mmc = calc_mmc(num1, num2)
print(f"\nO Mínimo Múltiplo Comum de {num1} e {num2} é {mmc}")

# 3) Escreva uma função que, dada uma lista de dois ou mais números inteiros positivos, calcule e retorne o Máximo Divisor Comum (MDC) entre eles.

def mdc(a, b):
    while b != 0:
        resto = a % b
        a = b
        b = resto
    return a

def mdc_lista(numeros):
    if len(numeros) < 2:
        raise ValueError("A lista deve conter pelo menos dois números.")

    mdc_atual = numeros[0]
    for i in range(1, len(numeros)):
        mdc_atual = mdc(mdc_atual, numeros[i])

    return mdc_atual

numeros = []
continuar = True

while continuar:
    numero = int(input("Digite um valor ou digite 0 para parar: "))
    if numero == 0:
        continuar = False
    else:
        numeros.append(numero)

print(f"Os números informados são: {numeros}")
print(f"O Máximo Divisor Comum dos números informados é: {mdc_lista(numeros)}")

# 4) Escreva uma função que, dada uma lista de dois ou mais números inteiros positivos, calcule e retorne o Mínimo Múltiplo Comum (MMC) entre eles.

def mmc(a, b):
    return abs(a * b) // mdc(a, b)

def mmc_lista(numeros):
    if len(numeros) < 2:
        raise ValueError("A lista deve conter pelo menos dois números.")

    mmc_atual = numeros[0]
    for i in range(1, len(numeros)):
        mmc_atual = mmc(mmc_atual, numeros[i])

    return mmc_atual

numeros = []
continuar = True

while continuar:
    numero = int(input("Informe um valor ou digite 0 para parar: "))
    if numero == 0:
        continuar = False
    else:
        numeros.append(numero)

print(f"Os números informados são: {numeros}")
print(f"O Mínimo Múltiplo Comum dos números informados é: {mmc_lista(numeros)}")

# 5) Escreva uma função que dado um número inteiro (n > 1), retorne uma lista com os fatores primos de n.

def primo(n):
    fatores = []
    divisor = 2
    while n > 1:
        while n % divisor == 0:
            fatores.append(divisor)
            n //= divisor
        divisor += 1
    return fatores

num = int(input("Informe um número inteiro maior que 1: "))
if num <= 1:
  print("O número deve ser maior que 1.")
else:
  print(f"Os fatores primos de {num} são: {primo(num)}")

# 6) Implemente uma função para calcular o número de combinações possíveis de m elementos em grupos de n elementos ( n < ou igual a m), dado pela fórmula de combinação: m!/(m-n)!n!

import math

def calc_combinacoes(m, n):
    if n > m:
        raise ValueError("N não pode ser maior que M.")
    combinacoes = math.factorial(m) / (math.factorial(m - n) * math.factorial(n))
    return combinacoes

m = int(input("Informe o número total de elementos (M): "))
n = int(input(f"Informe o número de elementos em cada grupo (n <= {m}): "))

print(f"O número de combinações possíveis é: {int(calc_combinacoes(m, n))}")

# 7) Implemente uma função que, dada uma lista, retorne uma outra lista, com os elementos da lista original, sem repetições.

def rep(lista):
    nova_lista = list(set(lista))
    nova_lista = sorted(nova_lista)
    return nova_lista

total_elementos = int(input("Digite o número de elementos na lista: "))
lista_original = []

for i in range(total_elementos):
    elemento = input(f"Digite o {i+1}º elemento da lista: ")
    lista_original.append(elemento)

nova_lista = rep(lista_original)
print(f"Lista original: {lista_original}")
print(f"Lista sem repetições: {nova_lista}")

# 8) Implemente uma função que, dada uma lista, retorne a moda da lista, ou seja, uma lista com o(s) elemento(s) mais frequente(s) da lista original.

def calc_moda(lista):
    frequencias = {}
    for i in lista:
        if i in frequencias:
            frequencias[i] += 1
        else:
            frequencias[i] = 1

    moda = []
    max_ocorrencias = max(frequencias.values())
    for key, value in frequencias.items():
        if value == max_ocorrencias:
            moda.append(key)

    return moda

total_elementos = int(input("Digite o número de elementos na lista: "))
lista = []

for i in range(total_elementos):
    elemento = int(input(f"Digite o {i+1}º elemento da lista: "))
    lista.append(elemento)

moda = calc_moda(lista)
print(f"A moda da lista é: {moda}")

# 9) Implemente uma função que, dada duas listas representando dois conjuntos, retorne uma lista que represente a união dos dois conjuntos.

def uniao_conjuntos(lista1, lista2):
    conjunto1 = set(lista1)
    conjunto2 = set(lista2)
    uniao = list(conjunto1.union(conjunto2))
    uniao = sorted(uniao)
    return uniao

conjunto1 = list(map(int, input("Digite os elementos do primeiro conjunto separados por espaço: ").split()))
conjunto2 = list(map(int, input("Digite os elementos do segundo conjunto separados por espaço: ").split()))

uniao = uniao_conjuntos(conjunto1, conjunto2)
print(f"A união dos conjuntos é: {uniao}")

# 10) Implemente uma função que, dada duas listas representando dois conjuntos, retorne uma lista que represente a intersecção dos dois conjuntos.
# tentei utilizar o que foi ensinado na máteria de projeto integrador, plotando o diagrama de venn.
# no diagrama, ele mostra a quantidade de valores por conjunto, e a quantidade na intersecção.

import matplotlib.pyplot as plt
from matplotlib_venn import venn2

def intersecao_conjuntos(lista1, lista2):
    conjunto1 = set(lista1)
    conjunto2 = set(lista2)
    intersecao = conjunto1.intersection(conjunto2)
    return intersecao

conjunto1 = list(map(int, input("Digite os elementos do primeiro conjunto separados por espaço: ").split()))
conjunto2 = list(map(int, input("Digite os elementos do segundo conjunto separados por espaço: ").split()))

intersecao = intersecao_conjuntos(conjunto1, conjunto2)
print(f"A interseção dos conjuntos é: {intersecao}")

# gráfico
venn = venn2(subsets=(len(set(conjunto1)), len(set(conjunto2)), len(intersecao)), set_labels=('Conjunto 1', 'Conjunto 2'))
venn.get_patch_by_id('10').set_color('skyblue')
venn.get_patch_by_id('01').set_color('skyblue')
venn.get_patch_by_id('11').set_color('blue')

plt.title('Diagrama de Venn para a Interseção dos Conjuntos')
plt.show()

# 11) Implemente uma função que, dada duas listas representando dois conjuntos, retorne uma lista que represente a diferença dos dois conjuntos.

def diferenca_conjuntos(lista1, lista2):
    conjunto1 = set(lista1)
    conjunto2 = set(lista2)
    diferenca = conjunto1.difference(conjunto2)
    return diferenca

conjunto1 = list(map(int, input("Digite os elementos do primeiro conjunto separados por espaço: ").split()))
conjunto2 = list(map(int, input("Digite os elementos do segundo conjunto separados por espaço: ").split()))

diferenca = diferenca_conjuntos(conjunto1, conjunto2)
print(f"A diferença dos conjuntos é: {diferenca}")

# 12) Implemente uma função que, dada duas listas representando dois conjuntos, verifique se o primeiro é um subconjunto do segundo.

def e_subconjunto(lista1, lista2):
    conjunto1 = set(lista1)
    conjunto2 = set(lista2)
    return conjunto1.issubset(conjunto2)

conjunto1 = list(map(int, input("Digite os elementos do primeiro conjunto separados por espaço: ").split()))
conjunto2 = list(map(int, input("Digite os elementos do segundo conjunto separados por espaço: ").split()))

if e_subconjunto(conjunto1, conjunto2):
    print("O primeiro conjunto é um subconjunto do segundo.")
else:
    print("O primeiro conjunto não é um subconjunto do segundo.")